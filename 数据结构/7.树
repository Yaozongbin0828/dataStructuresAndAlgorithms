树（Tree）是一种非常常见的数据结构，它由节点（Node）组成，节点之间通过边（Edge）相连。树的基本概念如下：

1. **根节点（Root）**：树的顶端节点，没有父节点的节点称为根节点。

2. **父节点和子节点**：除了根节点外，每个节点都有一个父节点，一个父节点可以有多个子节点。

3. **叶节点（Leaf）**：没有子节点的节点称为叶节点，也可以称为终端节点。

4. **子树（Subtree）**：树中的任意节点和它的后代节点（包括自身）可以组成一个子树。

5. **深度（Depth）**：从根节点到某个节点的唯一路径上的边的数量。

6. **高度（Height）**：树中节点的最大深度。

树结构在计算机科学中有着广泛的应用，比如在文件系统中用于组织文件和文件夹、在数据库中用于表示层次关系、在编程中用于实现各种算法等。

1、树
术语：

结点（包含数据和分支）、结点的度（结点的子树数）、树的度（树中各结点度的最大值）、叶子（度为零）、分支结点（度不为零）、兄弟结点、层数、树的深度（高度）、森林（零或者有限棵互不相交的树的集合）、有序树（结点的子树从左到右有序）和无序树。
树根（根节点），有且仅有一个，无前驱结点。
表示法

嵌套集合法（文氏图法）
圆括号表示法
凹入法
2、二叉树
特殊的有序树。
**性质1：**一颗非空二叉树的第i层上最多有2^(i-1)个结点（i>=1）。
**性质2：**深度为h的二叉树中，最多具有2^h-1个结点（h>=1）。

**性质3：**对于一颗有n个结点的完全二叉树，若按满二叉树的同样方法对结点进行编号，则对于任意序号为i的结点，有：

（父结点）：若i=1，则序号为i的结点是根结点。若i>1，则序号为i的结点的父结点的序号为（向下取整i/2）。
（左孩子）：若2i<=n，则序号为i的结点的左孩子结点的序号为2i。若2i>n，则序号为i的结点无左孩子。
（右孩子）：若2i+1<=n，则序号为i的结点的右孩子结点的序号为2i+1。若2i+1>n，则序号为i的结点无右孩子。
**性质4：**具有n(n>0)个结点的完全二叉树（包括满二叉树）的深度(h)为（向下取整log2^n）+1。

**性质5：**对于一颗非空的二叉树，设n0, n1, n2分别为表示度为0、1、2的结点个数，则有n0=n2+1。
满二叉树
深度为h，且有2^h-1个结点的二叉树。
完全二叉树
深度为h，有n个结点的二叉树。当且仅当每一个结点都与深度为h的满二叉树中编号从1至n的结点一一对应时，缺失部分一定是右边的。
存储
一般二叉树：

            链式存储（二叉链表，左数右、三叉链表，左数右父）  
    **完全二叉树或满二叉树：**

            顺序存储（既能节省空间，又能利用下标确定结点在二叉树中的位置）  
1
2
3
4
3、遍历二叉树和线索二叉树
1. 遍历二叉树

先序遍历(DLR，根左右)
中序遍历(LDR，左根右)
后序遍历(LRD，左右根)
层次遍历（逐层访问，自上而下，从左到右）
2. 恢复二叉树
前序+中序（前序确定根节点，中序确定左子树和右子树）

根据前序序列确定根节点，根据中序序列确定左子树和右子树。
分别找出左子树和右子树的根节点，并把左、右子树的根节点连到父节点上。
对左子树和右子树重复以上两步，直到子树只剩下1个结点或2个结点或空为止。
中序+后序（后序确定根节点，中序确定左子树和右子树）

    同上  
1
3. 线索二叉树
带有线索（指向直接前驱结点或指向直接后继结点的指针）的二叉树。
优点：
**·**进行中序遍历时不必采用堆栈处理，遍历速度快，节约存储空间。
**·**任意一个结点能直接找到它相应遍历顺序的直接前驱和直接后继结点。
缺点：
**·**节点的插入和删除麻烦且速度慢。
**·**线索树不能共用。
线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程。
先序线索二叉树、中序线索二叉树（中序线索化使用最多）、后序线索二叉树。
4、二叉树的转换
一般树转换为二叉树
把一般树的长子作为其父结点的左子树，次弟作为其兄结点的右子树。

方法：

连线：链接树中所有相邻的亲兄弟之间连线。
删线：保留父结点与长子的连线，打断父结点与非长子之间的连线。
旋转：以根节点为轴心，将整棵树顺时针旋转一定的角度，使之层次分明。
森林转换为二叉树

    森林是若干棵树的集合。只要将森林中的每一棵树的根视为兄弟，而每一棵树又可以用二叉树表示，这样，森林也就可以用二叉树来表示了。  
1
方法:
（1）将森林中的每一棵树转换成相应的二叉树。
（2）第一棵二叉树保持不动，从第二棵二叉树开始，依次把后一棵二叉树的根结
点作为前一棵二叉树根结点的右子树，直到把最后一棵二叉树的根结点作为其前一棵二叉树的右子树为止。

二叉树转换为树和森林

    树转换为二叉树以后,其根结点必定无右子树;而森林转换为二叉树以后，其根结点有右分支。显然这一转换过程是可逆的，即可以依据二叉树的根结点有无右子树，将一棵二叉树还原为树或森林。  
1
方法：
（1）若某结点是其父结点的左孩子，则把该结点的右孩子、右孩子的右孩子，直到最后一个石核于都与该结点的父结点连起来。
（2）删除原二叉树中所有的父结点与右孩子结点的连线。
（3）整理(1)、(2)的结果，使之层次分明。

5、哈夫曼树
注意：满二叉树不是哈夫曼树

术语：

路径长度（结点间）、树的路径长度（根结点到每个结点的路径长度之和）、结点的带权路径长度（结点到根结点之间路径长度与该结点上的权的乘积）、树的带权路径长度（树中所有叶子结点的带权路径长度之和）。
注：决策判定问题中，哈夫曼树可以获得最佳的决策算法。
基本思想

（1）由给定的n个权值{W1,W2,…,Wn}构造n棵只有一个叶结点的二叉树，从而得到一个二叉树的集合F={T1,T2，…, Tn}。
（2）在F中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和。
（3）在集合F中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F中。

（4）重复（2)、(3）两步，直到F中只剩下一棵二叉树时，这棵二叉树便是所要建立的哈夫曼树。

哈夫曼编码

在数据通信中，经常需要将传送的文字转换成由二进制字符0和1组成的二进制代码,称之为编码。如果在编码时考虑字符出现的频率，让出现频率高的字符采用尽可能短的编码，出现频率低的字符采用稍长的编码，构造一种不等长编码，则电文的代码就可能更短。  
    **哈夫曼编码**是一种用于构造使电文的编码总长最短的编码方案。
